mean.se=round(c(sd(ma.wtdmeans.all), sd(ma.wtdmeans.exclude)), 3)
)
row.names(ma.df) <- c("All trials", "Exclude early stopped")
ma.df
ma.df <- data.frame(reps=rep(nsims, 2),
mean.studies=c(5, mean.trials),
bias=round(c(mean(ma.bias.all), mean(ma.bias.exclude)), 5),
mean.se=round(c(sd(ma.wtdmeans.all), sd(ma.wtdmeans.exclude)), 3)
)
row.names(ma.df) <- c("All trials", "Exclude early stopped")
ma.df
# Summary estimate and bias, excluding adaptive design if stopped early:
ma.wtdmeans.exclude <- ma.wtdmeans.all
for(i in (1:nsims)[ad.results.for.ma$early.stop==TRUE]){
ma.wtdmeans.exclude[i] <- weighted.mean(x=ma.theta.hat[i, 2:5], w=1/ma.se[i, 2:5]^2)
}
ma.bias.exclude <- ma.wtdmeans.exclude-ma.theta
mean.trials <- 4+mean(ad.results.for.ma$early.stop==FALSE)
ma.df <- data.frame(reps=rep(nsims, 2),
mean.studies=c(5, mean.trials),
bias=round(c(mean(ma.bias.all), mean(ma.bias.exclude)), 5),
mean.se=round(c(sd(ma.wtdmeans.all), sd(ma.wtdmeans.exclude)), 3)
)
row.names(ma.df) <- c("All trials", "Exclude early stopped")
ma.df
# We vary response rate theta from 0.1 to 0.9
#### Find Simon designs and select optimal designs ####
all.designs <- clinfun::ph2simon(pu=0.5, pa=0.6, ep1=0.05, ep2=0.1, nmax=500)
# Choose optimal Simon design:
opt.index <- which.min(all.designs$out[, "EN(p0)"])
des <- all.designs$out[opt.index, ]
##### Obtain bias for range of true response probabilities ####
theta.vec <- seq(0.1, 0.9, 0.1)
summary.data <- vector("list", length(theta.vec))
raw.data <- vector("list", length(theta.vec))
nsims <- 10000
for(i in 1:length(theta.vec)){
one.run <- pwbSimon(theta=theta.vec[i], des=des, nsims=nsims)
raw.data[[i]] <- one.run$results
summary.data[[i]] <- one.run$ests
}
all.simon <- do.call(rbind, summary.data)
stop.early.count.index <- grepl("Stopped early", rownames(all.simon))
stop.early.count <- round(all.simon$nsims[stop.early.count.index]/nsims, 3)
#### Meta-analysis: Simulate 4*nsims further trials  ####
N <- des[names(des)=="n"] # max sample size of Simon design
ma.responses <- vector("list", nsims)
ma.theta <- 0.6
for(i in 1:nsims){
ma.responses[[i]] <- rbinom(n=4, size=N, prob=ma.theta)
}
ma.responses <- do.call(rbind, ma.responses)
ma.theta.hat <- ma.responses/N
ma.se <- sqrt((ma.theta.hat)*(1-ma.theta.hat)/N)
# Add the corresponding AD results to the MA results:
ad.results.for.ma <- raw.data[[which(theta.vec==ma.theta)]]
ma.theta.hat <- cbind(ad.results.for.ma$theta.hat, ma.theta.hat)
ma.se <- cbind(ad.results.for.ma$se, ma.se)
# Summary estimate and bias for all 5 trials:
ma.wtdmeans.all <- rep(NA, nsims)
for(i in 1:nrow(ma.theta.hat)){
ma.wtdmeans.all[i] <- weighted.mean(x=ma.theta.hat[i, ], w=1/ma.se[i, ]^2)
}
ma.bias.all <- ma.wtdmeans.all-ma.theta
# Summary estimate and bias, excluding adaptive design if stopped early:
ma.wtdmeans.exclude <- ma.wtdmeans.all
for(i in (1:nsims)[ad.results.for.ma$early.stop==TRUE]){
ma.wtdmeans.exclude[i] <- weighted.mean(x=ma.theta.hat[i, 2:5], w=1/ma.se[i, 2:5]^2)
}
ma.bias.exclude <- ma.wtdmeans.exclude-ma.theta
mean.trials <- 4+mean(ad.results.for.ma$early.stop==FALSE)
ma.df <- data.frame(reps=rep(nsims, 2),
mean.studies=c(5, mean.trials),
bias=round(c(mean(ma.bias.all), mean(ma.bias.exclude)), 5),
mean.se=round(c(sd(ma.wtdmeans.all), sd(ma.wtdmeans.exclude)), 3)
)
row.names(ma.df) <- c("All trials", "Exclude early stopped")
ma.df
#### Meta-analysis: Simulate 4*nsims further trials  ####
N <- des[names(des)=="n"] # max sample size of Simon design
ma.responses <- vector("list", nsims)
ma.theta <- 0.5
for(i in 1:nsims){
ma.responses[[i]] <- rbinom(n=4, size=N, prob=ma.theta)
}
ma.responses <- do.call(rbind, ma.responses)
ma.theta.hat <- ma.responses/N
ma.se <- sqrt((ma.theta.hat)*(1-ma.theta.hat)/N)
# Add the corresponding AD results to the MA results:
ad.results.for.ma <- raw.data[[which(theta.vec==ma.theta)]]
ma.theta.hat <- cbind(ad.results.for.ma$theta.hat, ma.theta.hat)
ma.se <- cbind(ad.results.for.ma$se, ma.se)
# Summary estimate and bias for all 5 trials:
ma.wtdmeans.all <- rep(NA, nsims)
for(i in 1:nrow(ma.theta.hat)){
ma.wtdmeans.all[i] <- weighted.mean(x=ma.theta.hat[i, ], w=1/ma.se[i, ]^2)
}
ma.bias.all <- ma.wtdmeans.all-ma.theta
# Summary estimate and bias, excluding adaptive design if stopped early:
ma.wtdmeans.exclude <- ma.wtdmeans.all
for(i in (1:nsims)[ad.results.for.ma$early.stop==TRUE]){
ma.wtdmeans.exclude[i] <- weighted.mean(x=ma.theta.hat[i, 2:5], w=1/ma.se[i, 2:5]^2)
}
ma.bias.exclude <- ma.wtdmeans.exclude-ma.theta
mean.trials <- 4+mean(ad.results.for.ma$early.stop==FALSE)
ma.df <- data.frame(reps=rep(nsims, 2),
mean.studies=c(5, mean.trials),
bias=round(c(mean(ma.bias.all), mean(ma.bias.exclude)), 5),
mean.se=round(c(sd(ma.wtdmeans.all), sd(ma.wtdmeans.exclude)), 3)
)
row.names(ma.df) <- c("All trials", "Exclude early stopped")
ma.df
theta
stop.early.count
##### Obtain bias for single true response probability ####
theta <- 0.5
raw.data <- vector("list", length(theta.vec))
nsims <- 10000
one.run <- pwbSimon(theta=theta, des=des, nsims=nsims)
raw.data <- one.run$results
raw.data
one.run
ad.results.for.ma
raw.data
#### Find Simon designs and select optimal designs ####
all.designs <- clinfun::ph2simon(pu=0.5, pa=0.6, ep1=0.05, ep2=0.1, nmax=500)
# Choose optimal Simon design:
opt.index <- which.min(all.designs$out[, "EN(p0)"])
des <- all.designs$out[opt.index, ]
##### Obtain bias for single true response probability ####
theta <- 0.5
simon.data <- vector("list", length(theta.vec))
nsims <- 10000
one.run <- pwbSimon(theta=theta, des=des, nsims=nsims)
simon.data <- one.run$results
#### Meta-analysis: Simulate further trials  ####
n.studies <- 4
N <- des[names(des)=="n"] # max sample size of Simon design
responses <- vector("list", nsims)
for(i in 1:nsims){
responses[[i]] <- rbinom(n=n.studies, size=N, prob=theta)
}
responses <- do.call(rbind, responses)
theta.hat <- responses/N
se <- sqrt((theta.hat)*(1-theta.hat)/N)
# Combine results from Simon simulation and MA simulation:
theta.hat <- cbind(simon.data$theta.hat, theta.hat)
se <- cbind(simon.data$se, se)
# Summary estimate and bias for all 5 trials:
wtdmeans.all <- rep(NA, nsims)
for(i in 1:nrow(theta.hat)){
wtdmeans.all[i] <- weighted.mean(x=theta.hat[i, ], w=1/se[i, ]^2)
}
bias.all <- wtdmeans.all-theta
# Summary estimate and bias, excluding adaptive design if stopped early:
wtdmeans.exclude <- wtdmeans.all
for(i in (1:nsims)[simon.data$early.stop==TRUE]){
wtdmeans.exclude[i] <- weighted.mean(x=theta.hat[i, 2:(n.studies+1)], w=1/se[i, 2:(n.studies+1)]^2)
}
bias.exclude <- wtdmeans.exclude-theta
mean.trials <- n.studies+mean(simon.data$early.stop==FALSE)
# Present results #
ma.df <- data.frame(reps=rep(nsims, 2),
mean.studies=c(n.studies+1, mean.trials),
bias=round(c(mean(bias.all), mean(bias.exclude)), 5),
mean.se=round(c(sd(wtdmeans.all), sd(wtdmeans.exclude)), 3)
)
row.names(ma.df) <- c("All trials", "Exclude early stopped")
ma.df
maSimon <- function(theta=0.5, nsims=10000, n.studies=4, des=des){
##### Obtain bias for single true response probability ####
simon.data <- pwbSimon(theta=theta, des=des, nsims=nsims)$results
#### Meta-analysis: Simulate further trials  ####
N <- des[names(des)=="n"] # max sample size of Simon design
responses <- vector("list", nsims)
for(i in 1:nsims){
responses[[i]] <- rbinom(n=n.studies, size=N, prob=theta)
}
responses <- do.call(rbind, responses)
theta.hat <- responses/N
se <- sqrt((theta.hat)*(1-theta.hat)/N)
# Combine results from Simon simulation and MA simulation:
theta.hat <- cbind(simon.data$theta.hat, theta.hat)
se <- cbind(simon.data$se, se)
# Summary estimate and bias for all 5 trials:
wtdmeans.all <- rep(NA, nsims)
for(i in 1:nrow(theta.hat)){
wtdmeans.all[i] <- weighted.mean(x=theta.hat[i, ], w=1/se[i, ]^2)
}
bias.all <- wtdmeans.all-theta
# Summary estimate and bias, excluding adaptive design if stopped early:
wtdmeans.exclude <- wtdmeans.all
for(i in (1:nsims)[simon.data$early.stop==TRUE]){
wtdmeans.exclude[i] <- weighted.mean(x=theta.hat[i, 2:(n.studies+1)], w=1/se[i, 2:(n.studies+1)]^2)
}
bias.exclude <- wtdmeans.exclude-theta
mean.trials <- n.studies+mean(simon.data$early.stop==FALSE)
# Present results #
ma.df <- data.frame(reps=rep(nsims, 2),
mean.studies=c(n.studies+1, mean.trials),
bias=round(c(mean(bias.all), mean(bias.exclude)), 5),
mean.se=round(c(sd(wtdmeans.all), sd(wtdmeans.exclude)), 3)
)
row.names(ma.df) <- c("All trials", "Exclude early stopped")
return(ma.df)
}
maSimon()
maSimon(des=des)
library(devtools)
library(roxygen2)
library(usethis)
usethis::use_package("ggplot2")
usethis::use_package("gridExtra")
usethis::use_package("clinfun")
usethis::use_package("xtable")
usethis::use_package("DHARMa")
usethis::use_package("librarian")
?use_package
?use_dev_version
usethis::use_dev_package("curtailment", remote="martinlaw/curtailment")
usethis::use_dev_package("singlearm", remote="mjg211/singlearm")
# When you add documentation in the function file, run devtools::document() and roxygen will convert it into "real" documentation:
devtools::document()
pwbGS <- function(theta, des, interims, nsims=1e5){
##### Setup #####
N <- des$all.des[, "n"] # max sample size
results <- vector("list", nsims)
states.data <- vector("list", nsims+1)
##### Simulate many trials of this design #####
for(i in 1:nsims){
states.data[[i]] <- DHARMa::getRandomState(NULL)
onetrial <- rbinom(n=N, size=1, prob=theta) # Simulate one trial of N results
s.list <- cumsum(onetrial)[interims] # Number of responses at each interim
fail.stage <- match(TRUE, s.list <= finite.bounds$fail, nomatch=100) # Earliest crossing of futility bound
success.stage <- match(TRUE, s.list >= finite.bounds$success, nomatch=100)  # Earliest crossing of efficacy bound
reject <- success.stage<fail.stage
stop.stage <- min(fail.stage, success.stage)
final.n <- interims[stop.stage] # Trial sample size
final.s <- s.list[stop.stage] # Trial number of responses
results[[i]] <- c(final.s, final.n, reject)
}
states.data[[i+1]] <- DHARMa::getRandomState(NULL)
##### Combine simulation results into data frame: #####
results <- do.call(rbind, results)
colnames(results) <-  c("s", "n", "reject")
results <- data.frame(results)
results$complete <- results$n==140 # Trial continued to final stage
results$theta.hat <- results$s/results$n
results$se <- sqrt(results$theta.hat * (1-results$theta.hat) / results$n)
##### Analyse results #####
early.stop <- results[results$complete==FALSE, ]
stop.at.N <- results[results$complete==TRUE, ]
# Estimates of response rate:
early.stop.theta.bar <- mean(early.stop$theta.hat)
stop.at.N.theta.bar <- mean(stop.at.N$theta.hat)
all.theta.bar <- mean(results$theta.hat)
# Empirical SEs:
early.stop.emp.SE <- sqrt((1/(nrow(early.stop)-1)) * sum((early.stop$theta.hat-early.stop.theta.bar)^2))
stop.at.N.emp.SE <- sqrt((1/(nrow(stop.at.N)-1)) * sum((stop.at.N$theta.hat-stop.at.N.theta.bar)^2))
all.emp.SE <- sqrt((1/(nsims-1)) * sum((results$theta.hat-all.theta.bar)^2))
emp.SE <- c(early.stop.emp.SE,
stop.at.N.emp.SE,
all.emp.SE,
NA)
mean.SE <- c(mean(results$se[results$complete==FALSE]),
mean(results$se[results$complete==TRUE]),
mean(results$se),
weighted.mean(results$se, w=1/(results$se)^2))
theta.bar.vec <- c(early.stop.theta.bar,
stop.at.N.theta.bar,
all.theta.bar,
weighted.mean(x=results$theta.hat, w=1/(results$se)^2))
bias <- theta.bar.vec-theta
trials <- c(nrow(early.stop),
nrow(stop.at.N),
nsims,
nsims)
ests <- data.frame(nsims=trials,
bias=round(bias, 4),
mean.SE=round(mean.SE, 4),
emp.SE=round(emp.SE, 4),
theta)
row.names(ests) <- c("Stopped early", "Complete", "All", "All (precision-weghted)")
ests$type <- c("Stopped early (naive)", "Complete (naive)", "All (naive)", "All (precision-weghted)")
ests
mc.error.bias.all <- sqrt( 1/(nsims*(nsims-1)) * sum((results$theta.hat-all.theta.bar)^2) )
mc.error.bias.all
mc.error.se.all <- all.emp.SE/sqrt(2*(nsims-1))
mc.error.se.all
all.data <- list(results=results,
ests=ests,
mc.error=c(mc.error.bias.all, mc.error.se.all))
return(all.data)
}
ad <- curtailment::singlearmDesign(nmin=50,
nmax=140,
C=20,
minstop=40,
p0=0.5,
p1=0.6,
alpha=0.1,
power=0.8,
minthetaE=1,
maxthetaF=0,
max.combns=1e3)
ad
# Store interim points and corresponding stopping boundaries
diag <- curtailment::drawDiagram(ad) # diagram of design and stopping bounds
finite.bounds <- diag$bounds.mat[!is.infinite(diag$bounds.mat$success) | !is.infinite(diag$bounds.mat$fail), ]
interims <- finite.bounds$m
interims
# When you add documentation in the function file, run devtools::document() and roxygen will convert it into "real" documentation:
devtools::document()
# When you add documentation in the function file, run devtools::document() and roxygen will convert it into "real" documentation:
devtools::document()
rm(list = c("ad", "interims", "pwbGS"))`
rm(list = c("ad", "interims", "pwbGS"))
devtools::document()
?use_package
devtools::document()
#'
#' Examines bias for a single Simon design WRT a meta-analysis of non-adaptive designs
#'
#' @param theta true response probablity
#' @param des a realisation of a Simon design, formatted as per output of clinfun::ph2simon
#' @param nsims number of simulations (default 1e5)
#' @param n.studies number of non-adaptive studies in meta-analysis
#' @return Data frame of results
#' @export
#'
randomiseRPW = function(N, Pa, Pb){
P = c(Pa, Pb)
allocation = response = rep(0,N)
allocation[1] = rbinom(1,1,0.5)
response[1] = rbinom(1,1,P[allocation[1]+1])
urn = ifelse(response[1], allocation[1], 1-allocation[1])
urn = c(urn, rep(NA,N-1))
for (i in 2:N){
ball = sample(urn[1:(i-1)], 1) # chose one ball
allocation[i] = ball
response[i] = rbinom(1,1,P[allocation[i]+1])
urn[i] = ifelse(response[i], ball, 1-ball)
}
return(c(sum(allocation==0), sum(response[allocation==0]),
sum(allocation==1), sum(response[allocation==1])))
}
randomiseRPW(10, 0.5, 0.4)
?ifelse
devtools::document()
?use_data
rm(list=ls())
load("RPWsim.Rdata")
load("~/metabias/RPWsim.Rdata")
mtcars
sample(3, mtcars)
sample(3)
sample(10)
?save
nsim = 10^4
N = 1000
p0 = 0.25
p1 = 0.5
theta = log(1-p1)-log(1-p0)
set.seed(7)
theta_U = theta_D = theta_C = ID = IU = N1 = rep(NA, nsim)
Sys.time()
for(i in 1:nsim){
trial = randomiseRPW(N, p0, p1)
N0 = trial[1]
X0 = trial[2]
N1[i] = trial[3]
X1 = trial[4]
theta_U[i] = log(1 - X1/N1[i]) - log(1 - X0/N0)
IU[i] = 1/(1/(N1[i]-X1) + 1/(N0-X0) - 1/N1[i] - 1/N0)
phat = (X1/N1[i] + X0/N0)/2
v = (3 + 4*(phat-0.5))/(1 - 4*(phat-0.5))
vT = (1-X0/N0)/(2*(1-phat))
ID[i] = 1/(v/(N*vT*(1-vT)))
Fhat = ID[i]/IU[i]
theta_D[i] = log(N0/N1[i])
theta_C[i] = (theta_U[i] - Fhat*theta_D[i])/(1-Fhat)
}
IC = IU - ID
varC = 1/IC
varU = 1/IU
RPWsim <- data.frame(varC=varC,
varU=varU,
theta_C=theta_C,
theta_U=theta_U,
N1=N1
)
nsim = 10^3
N = 100
p0 = 0.25
p1 = 0.5
theta = log(1-p1)-log(1-p0)
set.seed(7)
theta_U = theta_D = theta_C = ID = IU = N1 = rep(NA, nsim)
Sys.time()
for(i in 1:nsim){
trial = randomiseRPW(N, p0, p1)
N0 = trial[1]
X0 = trial[2]
N1[i] = trial[3]
X1 = trial[4]
theta_U[i] = log(1 - X1/N1[i]) - log(1 - X0/N0)
IU[i] = 1/(1/(N1[i]-X1) + 1/(N0-X0) - 1/N1[i] - 1/N0)
phat = (X1/N1[i] + X0/N0)/2
v = (3 + 4*(phat-0.5))/(1 - 4*(phat-0.5))
vT = (1-X0/N0)/(2*(1-phat))
ID[i] = 1/(v/(N*vT*(1-vT)))
Fhat = ID[i]/IU[i]
theta_D[i] = log(N0/N1[i])
theta_C[i] = (theta_U[i] - Fhat*theta_D[i])/(1-Fhat)
}
IC = IU - ID
varC = 1/IC
varU = 1/IU
RPWsim <- data.frame(varC=varC,
varU=varU,
theta_C=theta_C,
theta_U=theta_U,
N1=N1
)
RPWsim
nsim = 10^3
N = 1000
p0 = 0.25
p1 = 0.5
theta = log(1-p1)-log(1-p0)
set.seed(7)
theta_U = theta_D = theta_C = ID = IU = N1 = rep(NA, nsim)
Sys.time()
for(i in 1:nsim){
trial = randomiseRPW(N, p0, p1)
N0 = trial[1]
X0 = trial[2]
N1[i] = trial[3]
X1 = trial[4]
theta_U[i] = log(1 - X1/N1[i]) - log(1 - X0/N0)
IU[i] = 1/(1/(N1[i]-X1) + 1/(N0-X0) - 1/N1[i] - 1/N0)
phat = (X1/N1[i] + X0/N0)/2
v = (3 + 4*(phat-0.5))/(1 - 4*(phat-0.5))
vT = (1-X0/N0)/(2*(1-phat))
ID[i] = 1/(v/(N*vT*(1-vT)))
Fhat = ID[i]/IU[i]
theta_D[i] = log(N0/N1[i])
theta_C[i] = (theta_U[i] - Fhat*theta_D[i])/(1-Fhat)
}
IC = IU - ID
varC = 1/IC
varU = 1/IU
RPWsim <- data.frame(varC=varC,
varU=varU,
theta_C=theta_C,
theta_U=theta_U,
N1=N1
)
RPWsim
save(RPWsim, "RPWsim.RData")
RPWsim <- data.frame(varC=varC,
varU=varU,
theta_C=theta_C,
theta_U=theta_U,
N1=N1
)
RPWsim
save(RPWsim, "RPWsim.RData")
save(RPWsim, file="RPWsim.RData")
getwd()
?use_data_raw
use_data_raw()
use_data_raw("RPWsim")
########### Single trial with early stopping
nsim = 10^3
N = 1000
p0 = 0.25
p1 = 0.5
theta = log(1-p1)-log(1-p0)
set.seed(7)
theta_U = theta_D = theta_C = ID = IU = N1 = rep(NA, nsim)
Sys.time()
for(i in 1:nsim){
trial = pwb::randomiseRPW(N, p0, p1)
N0 = trial[1]
X0 = trial[2]
N1[i] = trial[3]
X1 = trial[4]
theta_U[i] = log(1 - X1/N1[i]) - log(1 - X0/N0)
IU[i] = 1/(1/(N1[i]-X1) + 1/(N0-X0) - 1/N1[i] - 1/N0)
phat = (X1/N1[i] + X0/N0)/2
v = (3 + 4*(phat-0.5))/(1 - 4*(phat-0.5))
vT = (1-X0/N0)/(2*(1-phat))
ID[i] = 1/(v/(N*vT*(1-vT)))
Fhat = ID[i]/IU[i]
theta_D[i] = log(N0/N1[i])
theta_C[i] = (theta_U[i] - Fhat*theta_D[i])/(1-Fhat)
}
IC = IU - ID
varC = 1/IC
varU = 1/IU
RPWsim <- data.frame(varC=varC,
varU=varU,
theta_C=theta_C,
theta_U=theta_U,
N1=N1
)
#save(RPWsim, file="RPWsim.RData")
#
#save(RPWsim, file="RPWsim.RData")
#
usethis::use_data(RPWsim, overwrite = TRUE)
