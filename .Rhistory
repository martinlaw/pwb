)
########### 4 more studies with fixed sample size
RD_fixed = SE_fixed = matrix(nrow = nsim, ncol = 4)
for(j in 1:4){
for(i in 1:nsim){
X0 = rbinom(N/2, 1, 0.2)
X1 = rbinom(N/2, 1, 0.15)
EE = sum(X1)
EN = N/2 - EE
CE = sum(X0)
CN = N/2 - CE
RD_fixed[i,j] = (EE/(EE+EN)) - (CE/(CE+CN))
SE_fixed[i,j] = sqrt(EE*EN/(EE+EN)^3 + CE*CN/(CE+CN)^3)
}
# Meta-analysis
MA_all = MA_exclude = rep(NA, nsim)
for(i in 1:nsim){
if(pval[i] <= 0.001){
MA_all[i] = weighted.mean(c(RD_interim[i], RD_fixed[i,]),
c(1/SE_interim[i]^2, 1/SE_fixed[i,]^2))
MA_exclude[i] = weighted.mean(c(RD_fixed[i,]), c(1/SE_fixed[i,]^2))
} else {
MA_all[i] = MA_exclude[i] = weighted.mean(c(RD_final[i], RD_fixed[i,]),
c(1/SE_final[i]^2, 1/SE_fixed[i,]^2))
}
# Table (slide 19)
rbind(
c(nsim, 5, mean(MA_all)+0.05, sd(MA_all)),
c(nsim, 4+mean(continue), mean(MA_exclude)+0.05, sd(MA_exclude))
)
#### Find Simon designs and select optimal designs ####
all.designs <- clinfun::ph2simon(pu=0.5, pa=0.6, ep1=0.05, ep2=0.1, nmax=500)
# Choose optimal Simon design:
opt.index <- which.min(all.designs$out[, "EN(p0)"])
des <- all.designs$out[opt.index, ]
des
#### Simulate 4*nsims further trials, for meta-analysis ####
rbinom(n=4, size=233, prob=0.6)
nsims
#### Simulate 4*nsims further trials, for meta-analysis ####
N <- des[, "n"]
des
class(des)
names(des)
names(des)=="n"
#### Simulate 4*nsims further trials, for meta-analysis ####
N <- des[names(des)=="n"]
N
nsims=10
#### Simulate 4*nsims further trials, for meta-analysis ####
N <- des[names(des)=="n"] # max sample size of Simon design
ma.responses <- vector("list", nsims)
for(i in 1:nsims){
ma.responses[[i]] <- rbinom(n=4, size=N, prob=0.6)
}
ma.responses
#### Find Simon designs and select optimal designs ####
all.designs <- clinfun::ph2simon(pu=0.5, pa=0.6, ep1=0.05, ep2=0.1, nmax=500)
# Choose optimal Simon design:
opt.index <- which.min(all.designs$out[, "EN(p0)"])
des <- all.designs$out[opt.index, ]
##### Obtain bias for range of true response probabilities ####
theta.vec <- seq(0.1, 0.9, 0.1)
summary.data <- vector("list", length(theta.vec))
raw.data <- vector("list", length(theta.vec))
for(i in 1:length(theta.vec)){
one.run <- pwbSimon(theta=theta.vec[i], des=des, nsims=1e5)
raw.data[[i]] <- one.run$results
summary.data[[i]] <- one.run$ests
}
all.simon <- do.call(rbind, summary.data)
stop.early.count.index <- grepl("Stopped early", rownames(all.simon))
stop.early.count <- round(all.simon$nsims[stop.early.count.index]/1e5, 3)
##### UMVUE for Simon design #####
d2 <- des_gs(J=2,
pi0=0.5,
pi1=0.6,
alpha=0.05,
beta=0.1,
Nmin=233,
Nmax=233,
futility=TRUE,
efficacy=FALSE,
optimality="null_ess",
summary=TRUE)
est <- est_gs(des=d2, pi=theta.vec, method=c("umvue"))
umvue <- data.frame(matrix(ncol = length(names(all.simon)),
nrow = nrow(est$perf)))
names(umvue) <- names(all.simon)
umvue$theta <- est$perf$pi
umvue$bias <- est$perf$`Bias(hat(pi)|pi)`
umvue$type <- "UMVUE"
all.simon <- rbind(all.simon, umvue)
#### Simulate 4*nsims further trials, for meta-analysis ####
N <- des[names(des)=="n"] # max sample size of Simon design
ma.responses <- vector("list", nsims)
librarian::shelf(ggplot2, gridExtra, clinfun, xtable, DHARMa, martinlaw/curtailment, mjg211/singlearm)
# functions for finding precision weighted bias and displaying results:
source("R/pwbSimon.R")
source("R/pwbGS.R")
source("R/showTable.R")
##### Obtain bias for range of true response probabilities ####
theta.vec <- seq(0.1, 0.9, 0.1)
summary.data <- vector("list", length(theta.vec))
raw.data <- vector("list", length(theta.vec))
for(i in 1:length(theta.vec)){
one.run <- pwbSimon(theta=theta.vec[i], des=des, nsims=10)
raw.data[[i]] <- one.run$results
summary.data[[i]] <- one.run$ests
}
all.simon <- do.call(rbind, summary.data)
stop.early.count.index <- grepl("Stopped early", rownames(all.simon))
stop.early.count <- round(all.simon$nsims[stop.early.count.index]/1e5, 3)
all.simon
all.simon <- rbind(all.simon, umvue)
all.simon
raw.data
summary.data
raw.data
theta.vec
theta.vec==ma.theta
ma.theta <- 0.6
theta.vec==ma.theta
raw.data[[theta.vec==ma.theta]]
length(theta.vec)
length(raw.data)
raw.data[[6]]
theta.vec==ma.theta
ad.results.for.ma <-
raw.data[[which(theta.vec==ma.theta)]]
#ad.results.for.ma <-
raw.data[[which(theta.vec==ma.theta)]]
do.call(rbind, ma.responses)
ma.responses
do.call(rbind, ma.responses)
do.call("rbind", ma.responses)
summary.data
do.call(rbind, summary.data)
data.table::rbindlist(ma.responses)
ma.responses
for(i in 1:nsims){
ma.responses[[i]] <- rbinom(n=4, size=N, prob=ma.theta)
}
ma.responses
do.call(rbind, ma.responses)
ma.responses <- do.call(rbind, ma.responses)
ma.responses
ma.se <- (ma.responses/N)*(1-(ma.responses/N)/N)
ma.se
ma.responses/N
ma.theta.hat <- ma.responses/N
ma.theta.hat
(ma.theta.hat)*(1-(ma.theta.hat)/N)
ma.se <- sqrt((ma.theta.hat)*(1-(ma.theta.hat)/N))
ma.se
N
ma.responses
135/233
sqrt(0.58*0.42/233)
ma.theta.hat
ma.se <- sqrt((ma.theta.hat)*(1-ma.theta.hat)/N)
ma.se
ad.results.for.ma
cbind(ad.results.for.ma$theta.hat, ma.theta.hat)
ma.theta.hat <- cbind(ad.results.for.ma$theta.hat, ma.theta.hat)
cbind(ad.results.for.ma$se, ma.se)
ma.se <- cbind(ad.results.for.ma$se, ma.se)
sum(ad.results.for.ma$early.stop)
nsims
sum(ad.results.for.ma$early.stop)/nsims
sum(ad.results.for.ma$early.stop==FALSE)/nsims
mean(T,F,T)
mean(c(T,F,T))
mean(ad.results.for.ma$early.stop==FALSE)
##### Obtain bias for range of true response probabilities ####
theta.vec <- seq(0.1, 0.9, 0.1)
summary.data <- vector("list", length(theta.vec))
raw.data <- vector("list", length(theta.vec))
for(i in 1:length(theta.vec)){
one.run <- pwbSimon(theta=theta.vec[i], des=des, nsims=1000)
raw.data[[i]] <- one.run$results
summary.data[[i]] <- one.run$ests
}
all.simon <- do.call(rbind, summary.data)
stop.early.count.index <- grepl("Stopped early", rownames(all.simon))
stop.early.count <- round(all.simon$nsims[stop.early.count.index]/1e5, 3)
stop.early.count
#### Find Simon designs and select optimal designs ####
all.designs <- clinfun::ph2simon(pu=0.5, pa=0.6, ep1=0.05, ep2=0.1, nmax=500)
# Choose optimal Simon design:
opt.index <- which.min(all.designs$out[, "EN(p0)"])
des <- all.designs$out[opt.index, ]
##### Obtain bias for range of true response probabilities ####
theta.vec <- seq(0.1, 0.9, 0.1)
summary.data <- vector("list", length(theta.vec))
raw.data <- vector("list", length(theta.vec))
nsims <- 1000
for(i in 1:length(theta.vec)){
one.run <- pwbSimon(theta=theta.vec[i], des=des, nsims=nsims)
raw.data[[i]] <- one.run$results
summary.data[[i]] <- one.run$ests
}
all.simon <- do.call(rbind, summary.data)
stop.early.count.index <- grepl("Stopped early", rownames(all.simon))
stop.early.count <- round(all.simon$nsims[stop.early.count.index]/nsims, 3)
stop.early.count
all.simon
#### Simulate 4*nsims further trials, for meta-analysis ####
N <- des[names(des)=="n"] # max sample size of Simon design
ma.responses <- vector("list", nsims)
ma.theta <- 0.6
for(i in 1:nsims){
ma.responses[[i]] <- rbinom(n=4, size=N, prob=ma.theta)
}
ma.responses <- do.call(rbind, ma.responses)
ma.theta.hat <- ma.responses/N
ma.se <- sqrt((ma.theta.hat)*(1-ma.theta.hat)/N)
ma.responses
# Add the corresponding AD results to the MA results:
ad.results.for.ma <- raw.data[[which(theta.vec==ma.theta)]]
ma.theta.hat <- cbind(ad.results.for.ma$theta.hat, ma.theta.hat)
ma.se <- cbind(ad.results.for.ma$se, ma.se)
mean.trials <- mean(ad.results.for.ma$early.stop==FALSE)
mean.trials
mean.trials <- 4+mean(ad.results.for.ma$early.stop==FALSE)
mean.trials
ad.results.for.ma$early.stop
stop.early.count.index
mapply(function(vec1, vec2) weighted.mean(x=vec1, w=1/vec2^2), ma.theta.hat, ma.se)
weighted.mean(x=ma.theta.hat[1,], w=1/ma.se[1,]^2)
wtdmeans <- rep(NA, nsims)
for(i in 1:nrow(ma.theta.hat)){
wtdmeans[i] <- weighted.mean(x=ma.theta.hat[1,], w=1/ma.se[1,]^2)
}
wtdmeans
for(i in 1:nrow(ma.theta.hat)){
wtdmeans[i] <- weighted.mean(x=ma.theta.hat[i, ], w=1/ma.se[i, ]^2)
}
wtdmeans
mapply(function(vec1, vec2) weighted.mean(x=vec1, w=1/vec2^2), ma.theta.hat, ma.se)
head(wtdmeans)
xxx <- mapply(function(vec1, vec2) weighted.mean(x=vec1, w=1/vec2^2), ma.theta.hat, ma.se)
head(xxx)
ma.wtdmeans <- rep(NA, nsims)
for(i in 1:nrow(ma.theta.hat)){
ma.wtdmeans[i] <- weighted.mean(x=ma.theta.hat[i, ], w=1/ma.se[i, ]^2)
}
ma.wtdmeans
weighted.mean(x=ma.theta.hat[10, ], w=1/ma.se[10, ]^2)
ma.theta
ma.bias.all <- ma.wtdmeans-ma.theta
plot(ma.bias.all)
summary(ma.bias.all)
hist(ma.bias.all)
ad.results.for.ma
summary.data
raw.data
for(i in 1:nsims[ad.results.for.ma$early.stop==TRUE]){
print(i)
}
for(i in (1:nsims)[ad.results.for.ma$early.stop==TRUE]){
print(i)
}
ma.wtdmeans
ma.wtdmeans.exclude <- ma.wtdmeans.all
ma.wtdmeans.all <- rep(NA, nsims)
for(i in 1:nrow(ma.theta.hat)){
ma.wtdmeans.all[i] <- weighted.mean(x=ma.theta.hat[i, ], w=1/ma.se[i, ]^2)
}
ma.wtdmeans.exclude
ma.wtdmeans.exclude <- ma.wtdmeans.all
ma.wtdmeans.exclude
for(i in (1:nsims)[ad.results.for.ma$early.stop==TRUE]){
ma.wtdmeans.exclude[i] <- weighted.mean(x=ma.theta.hat[i, 1:4], w=1/ma.se[i, 1:4]^2)
}
ma.theta
# Summary estimate and bias, excluding AD if stopped early
ma.wtdmeans.exclude <- ma.wtdmeans.all
for(i in (1:nsims)[ad.results.for.ma$early.stop==TRUE]){
ma.wtdmeans.exclude[i] <- weighted.mean(x=ma.theta.hat[i, 1:4], w=1/ma.se[i, 1:4]^2)
}
ma.bias.exclude <- ma.wtdmeans.exclude-ma.theta
summary(ma.bias.exclude)
summary(ma.bias.all)
sd(ma.bias.all)
sd(ma.wtdmeans.all)
rbind(
c(nsim, 5, mean(MA_all)+0.05, sd(MA_all)),
c(nsim, 4+mean(continue), mean(MA_exclude)+0.05, sd(MA_exclude))
)
sd(ma.wtdmeans.exclude)
mean.trials
showTable()
showTable
ma.df <- data.frame(reps=rep(nsims, 2),
mean.studies=c(5, mean.trials),
bias=c(mean(ma.bias.all), mean(ma.bias.exclude)),
mean.se=c(sd(ma.wtdmeans.all), sd(ma.wtdmeans.exclude)))
ma.df
row.names(ma.df) <- c("All trials", "Exclude early stopped")
ma.df
ma.df <- data.frame(reps=rep(nsims, 2),
mean.studies=c(5, mean.trials),
bias=round(c(mean(ma.bias.all), mean(ma.bias.exclude)), 4),
mean.se=round(c(sd(ma.wtdmeans.all), sd(ma.wtdmeans.exclude)), 3)
)
row.names(ma.df) <- c("All trials", "Exclude early stopped")
ma.df
ma.df <- data.frame(reps=rep(nsims, 2),
mean.studies=c(5, mean.trials),
bias=round(c(mean(ma.bias.all), mean(ma.bias.exclude)), 5),
mean.se=round(c(sd(ma.wtdmeans.all), sd(ma.wtdmeans.exclude)), 3)
)
row.names(ma.df) <- c("All trials", "Exclude early stopped")
ma.df
# Summary estimate and bias, excluding adaptive design if stopped early:
ma.wtdmeans.exclude <- ma.wtdmeans.all
for(i in (1:nsims)[ad.results.for.ma$early.stop==TRUE]){
ma.wtdmeans.exclude[i] <- weighted.mean(x=ma.theta.hat[i, 2:5], w=1/ma.se[i, 2:5]^2)
}
ma.bias.exclude <- ma.wtdmeans.exclude-ma.theta
mean.trials <- 4+mean(ad.results.for.ma$early.stop==FALSE)
ma.df <- data.frame(reps=rep(nsims, 2),
mean.studies=c(5, mean.trials),
bias=round(c(mean(ma.bias.all), mean(ma.bias.exclude)), 5),
mean.se=round(c(sd(ma.wtdmeans.all), sd(ma.wtdmeans.exclude)), 3)
)
row.names(ma.df) <- c("All trials", "Exclude early stopped")
ma.df
# We vary response rate theta from 0.1 to 0.9
#### Find Simon designs and select optimal designs ####
all.designs <- clinfun::ph2simon(pu=0.5, pa=0.6, ep1=0.05, ep2=0.1, nmax=500)
# Choose optimal Simon design:
opt.index <- which.min(all.designs$out[, "EN(p0)"])
des <- all.designs$out[opt.index, ]
##### Obtain bias for range of true response probabilities ####
theta.vec <- seq(0.1, 0.9, 0.1)
summary.data <- vector("list", length(theta.vec))
raw.data <- vector("list", length(theta.vec))
nsims <- 10000
for(i in 1:length(theta.vec)){
one.run <- pwbSimon(theta=theta.vec[i], des=des, nsims=nsims)
raw.data[[i]] <- one.run$results
summary.data[[i]] <- one.run$ests
}
all.simon <- do.call(rbind, summary.data)
stop.early.count.index <- grepl("Stopped early", rownames(all.simon))
stop.early.count <- round(all.simon$nsims[stop.early.count.index]/nsims, 3)
#### Meta-analysis: Simulate 4*nsims further trials  ####
N <- des[names(des)=="n"] # max sample size of Simon design
ma.responses <- vector("list", nsims)
ma.theta <- 0.6
for(i in 1:nsims){
ma.responses[[i]] <- rbinom(n=4, size=N, prob=ma.theta)
}
ma.responses <- do.call(rbind, ma.responses)
ma.theta.hat <- ma.responses/N
ma.se <- sqrt((ma.theta.hat)*(1-ma.theta.hat)/N)
# Add the corresponding AD results to the MA results:
ad.results.for.ma <- raw.data[[which(theta.vec==ma.theta)]]
ma.theta.hat <- cbind(ad.results.for.ma$theta.hat, ma.theta.hat)
ma.se <- cbind(ad.results.for.ma$se, ma.se)
# Summary estimate and bias for all 5 trials:
ma.wtdmeans.all <- rep(NA, nsims)
for(i in 1:nrow(ma.theta.hat)){
ma.wtdmeans.all[i] <- weighted.mean(x=ma.theta.hat[i, ], w=1/ma.se[i, ]^2)
}
ma.bias.all <- ma.wtdmeans.all-ma.theta
# Summary estimate and bias, excluding adaptive design if stopped early:
ma.wtdmeans.exclude <- ma.wtdmeans.all
for(i in (1:nsims)[ad.results.for.ma$early.stop==TRUE]){
ma.wtdmeans.exclude[i] <- weighted.mean(x=ma.theta.hat[i, 2:5], w=1/ma.se[i, 2:5]^2)
}
ma.bias.exclude <- ma.wtdmeans.exclude-ma.theta
mean.trials <- 4+mean(ad.results.for.ma$early.stop==FALSE)
ma.df <- data.frame(reps=rep(nsims, 2),
mean.studies=c(5, mean.trials),
bias=round(c(mean(ma.bias.all), mean(ma.bias.exclude)), 5),
mean.se=round(c(sd(ma.wtdmeans.all), sd(ma.wtdmeans.exclude)), 3)
)
row.names(ma.df) <- c("All trials", "Exclude early stopped")
ma.df
#### Meta-analysis: Simulate 4*nsims further trials  ####
N <- des[names(des)=="n"] # max sample size of Simon design
ma.responses <- vector("list", nsims)
ma.theta <- 0.5
for(i in 1:nsims){
ma.responses[[i]] <- rbinom(n=4, size=N, prob=ma.theta)
}
ma.responses <- do.call(rbind, ma.responses)
ma.theta.hat <- ma.responses/N
ma.se <- sqrt((ma.theta.hat)*(1-ma.theta.hat)/N)
# Add the corresponding AD results to the MA results:
ad.results.for.ma <- raw.data[[which(theta.vec==ma.theta)]]
ma.theta.hat <- cbind(ad.results.for.ma$theta.hat, ma.theta.hat)
ma.se <- cbind(ad.results.for.ma$se, ma.se)
# Summary estimate and bias for all 5 trials:
ma.wtdmeans.all <- rep(NA, nsims)
for(i in 1:nrow(ma.theta.hat)){
ma.wtdmeans.all[i] <- weighted.mean(x=ma.theta.hat[i, ], w=1/ma.se[i, ]^2)
}
ma.bias.all <- ma.wtdmeans.all-ma.theta
# Summary estimate and bias, excluding adaptive design if stopped early:
ma.wtdmeans.exclude <- ma.wtdmeans.all
for(i in (1:nsims)[ad.results.for.ma$early.stop==TRUE]){
ma.wtdmeans.exclude[i] <- weighted.mean(x=ma.theta.hat[i, 2:5], w=1/ma.se[i, 2:5]^2)
}
ma.bias.exclude <- ma.wtdmeans.exclude-ma.theta
mean.trials <- 4+mean(ad.results.for.ma$early.stop==FALSE)
ma.df <- data.frame(reps=rep(nsims, 2),
mean.studies=c(5, mean.trials),
bias=round(c(mean(ma.bias.all), mean(ma.bias.exclude)), 5),
mean.se=round(c(sd(ma.wtdmeans.all), sd(ma.wtdmeans.exclude)), 3)
)
row.names(ma.df) <- c("All trials", "Exclude early stopped")
ma.df
theta
stop.early.count
##### Obtain bias for single true response probability ####
theta <- 0.5
raw.data <- vector("list", length(theta.vec))
nsims <- 10000
one.run <- pwbSimon(theta=theta, des=des, nsims=nsims)
raw.data <- one.run$results
raw.data
one.run
ad.results.for.ma
raw.data
#### Find Simon designs and select optimal designs ####
all.designs <- clinfun::ph2simon(pu=0.5, pa=0.6, ep1=0.05, ep2=0.1, nmax=500)
# Choose optimal Simon design:
opt.index <- which.min(all.designs$out[, "EN(p0)"])
des <- all.designs$out[opt.index, ]
##### Obtain bias for single true response probability ####
theta <- 0.5
simon.data <- vector("list", length(theta.vec))
nsims <- 10000
one.run <- pwbSimon(theta=theta, des=des, nsims=nsims)
simon.data <- one.run$results
#### Meta-analysis: Simulate further trials  ####
n.studies <- 4
N <- des[names(des)=="n"] # max sample size of Simon design
responses <- vector("list", nsims)
for(i in 1:nsims){
responses[[i]] <- rbinom(n=n.studies, size=N, prob=theta)
}
responses <- do.call(rbind, responses)
theta.hat <- responses/N
se <- sqrt((theta.hat)*(1-theta.hat)/N)
# Combine results from Simon simulation and MA simulation:
theta.hat <- cbind(simon.data$theta.hat, theta.hat)
se <- cbind(simon.data$se, se)
# Summary estimate and bias for all 5 trials:
wtdmeans.all <- rep(NA, nsims)
for(i in 1:nrow(theta.hat)){
wtdmeans.all[i] <- weighted.mean(x=theta.hat[i, ], w=1/se[i, ]^2)
}
bias.all <- wtdmeans.all-theta
# Summary estimate and bias, excluding adaptive design if stopped early:
wtdmeans.exclude <- wtdmeans.all
for(i in (1:nsims)[simon.data$early.stop==TRUE]){
wtdmeans.exclude[i] <- weighted.mean(x=theta.hat[i, 2:(n.studies+1)], w=1/se[i, 2:(n.studies+1)]^2)
}
bias.exclude <- wtdmeans.exclude-theta
mean.trials <- n.studies+mean(simon.data$early.stop==FALSE)
# Present results #
ma.df <- data.frame(reps=rep(nsims, 2),
mean.studies=c(n.studies+1, mean.trials),
bias=round(c(mean(bias.all), mean(bias.exclude)), 5),
mean.se=round(c(sd(wtdmeans.all), sd(wtdmeans.exclude)), 3)
)
row.names(ma.df) <- c("All trials", "Exclude early stopped")
ma.df
maSimon <- function(theta=0.5, nsims=10000, n.studies=4, des=des){
##### Obtain bias for single true response probability ####
simon.data <- pwbSimon(theta=theta, des=des, nsims=nsims)$results
#### Meta-analysis: Simulate further trials  ####
N <- des[names(des)=="n"] # max sample size of Simon design
responses <- vector("list", nsims)
for(i in 1:nsims){
responses[[i]] <- rbinom(n=n.studies, size=N, prob=theta)
}
responses <- do.call(rbind, responses)
theta.hat <- responses/N
se <- sqrt((theta.hat)*(1-theta.hat)/N)
# Combine results from Simon simulation and MA simulation:
theta.hat <- cbind(simon.data$theta.hat, theta.hat)
se <- cbind(simon.data$se, se)
# Summary estimate and bias for all 5 trials:
wtdmeans.all <- rep(NA, nsims)
for(i in 1:nrow(theta.hat)){
wtdmeans.all[i] <- weighted.mean(x=theta.hat[i, ], w=1/se[i, ]^2)
}
bias.all <- wtdmeans.all-theta
# Summary estimate and bias, excluding adaptive design if stopped early:
wtdmeans.exclude <- wtdmeans.all
for(i in (1:nsims)[simon.data$early.stop==TRUE]){
wtdmeans.exclude[i] <- weighted.mean(x=theta.hat[i, 2:(n.studies+1)], w=1/se[i, 2:(n.studies+1)]^2)
}
bias.exclude <- wtdmeans.exclude-theta
mean.trials <- n.studies+mean(simon.data$early.stop==FALSE)
# Present results #
ma.df <- data.frame(reps=rep(nsims, 2),
mean.studies=c(n.studies+1, mean.trials),
bias=round(c(mean(bias.all), mean(bias.exclude)), 5),
mean.se=round(c(sd(wtdmeans.all), sd(wtdmeans.exclude)), 3)
)
row.names(ma.df) <- c("All trials", "Exclude early stopped")
return(ma.df)
}
maSimon()
maSimon(des=des)
